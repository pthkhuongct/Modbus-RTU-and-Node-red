{"version":3,"sources":["modbus-flex-getter.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","nodes","registerType","config","internalDebugLog","createNode","this","name","showStatusActivities","showErrors","showWarnings","useIOFile","ioFile","getNode","useIOForPayload","logIOActivities","keepMsgProperties","verboseLogging","delayOnStart","settings","node","bufferMessageList","parseInt","Map","startDelayTime","delayOccured","inputDelayTimer","modbusClient","setNodeStatusTo","initModbusClientEvents","INPUT_TIMEOUT_MILLISECONDS","warn","logMessage","onModbusReadDone","registerForModbus","send","buildMessageWithIO","resp","msg","errorProtocolMsg","mbIOCore","data","onModbusReadError","err","origMsg","sendEmptyMsgOnFail","setModbusError","parse","message","payload","getOriginalMessage","unitid","address","isValidModbusMsg","isValid","Number","isInteger","fc","quantity","buildNewMessageObject","messageId","topic","error","emptyMsgOnFail","verboseWarn","isReadyForInput","isNotReadyForInput","resetInputDelayTimer","id","value","clearTimeout","initializeInputDelayTimer","client","isActive","prepareMsg","buildNewMessage","setTimeout","newMsg","on","done","setNodeDefaultStatus","isInactive","origMsgInput","Object","assign","inputMsg","set","emit","actualServiceState","clear","deregisterForModbus"],"mappings":"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","file":"../modbus-flex-getter.js","sourcesContent":["/**\n Copyright (c) since the year 2016 Klaus Landsdorf (http://plus4nodered.com/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n\n/**\n * Modbus flexible Getter node.\n * @module NodeRedModbusFlexGetter\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:flex:getter')\n\n  function ModbusFlexGetter (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.showWarnings = config.showWarnings\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.keepMsgProperties = config.keepMsgProperties\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    this.delayOnStart = config.delayOnStart\n    this.startDelayTime = parseInt(config.startDelayTime) || 10\n\n    const node = this\n    node.bufferMessageList = new Map()\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\n    node.delayOccured = false\n    node.inputDelayTimer = null\n\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n      node.emit('modbusFlexGetterNodeDone')\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\n      node.errorProtocolMsg(err, origMsg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\n      node.emit('modbusFlexGetterNodeError')\n    }\n\n    node.prepareMsg = function (msg) {\n      if (typeof msg.payload === 'string') {\n        msg.payload = JSON.parse(msg.payload)\n      }\n\n      msg.payload.fc = parseInt(msg.payload.fc) || 3\n      msg.payload.unitid = parseInt(msg.payload.unitid)\n      msg.payload.address = parseInt(msg.payload.address) || 0\n      msg.payload.quantity = parseInt(msg.payload.quantity) || 1\n\n      return msg\n    }\n\n    node.isValidModbusMsg = function (msg) {\n      let isValid = true\n\n      if (!(Number.isInteger(msg.payload.fc) &&\n        msg.payload.fc >= 1 &&\n        msg.payload.fc <= 4)) {\n        node.error('FC Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n        !(Number.isInteger(msg.payload.address) &&\n          msg.payload.address >= 0 &&\n          msg.payload.address <= 65535)) {\n        node.error('Address Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n        !(Number.isInteger(msg.payload.quantity) &&\n          msg.payload.quantity >= 1 &&\n          msg.payload.quantity <= 65535)) {\n        node.error('Quantity Not Valid', msg)\n        isValid &= false\n      }\n\n      return isValid\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const messageId = mbCore.getObjectId()\n      return {\n        topic: msg.topic || node.id,\n        messageId,\n        payload: {\n          value: msg.payload.value || msg.value,\n          unitid: msg.payload.unitid,\n          fc: msg.payload.fc,\n          address: msg.payload.address,\n          quantity: msg.payload.quantity,\n          emptyMsgOnFail: node.emptyMsgOnFail,\n          keepMsgProperties: node.keepMsgProperties,\n          messageId\n        }\n      }\n    }\n    /* istanbul ignore next */\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose && node.showWarnings) {\n        node.warn('Flex-Getter -> ' + logMessage)\n      }\n    }\n\n    node.isReadyForInput = function () {\n      return (modbusClient.client && modbusClient.isActive() && node.delayOccured)\n    }\n\n    node.isNotReadyForInput = function () {\n      return !node.isReadyForInput()\n    }\n\n    node.resetInputDelayTimer = function () {\n      if (node.inputDelayTimer) {\n        /* istanbul ignore next */\n        verboseWarn('reset input delay timer node ' + node.id)\n        clearTimeout(node.inputDelayTimer)\n      }\n      node.inputDelayTimer = null\n      node.delayOccured = false\n    }\n\n    node.initializeInputDelayTimer = function () {\n      node.resetInputDelayTimer()\n      if (node.delayOnStart) {\n        /* istanbul ignore next */\n        verboseWarn('initialize input delay timer node ' + node.id)\n        node.inputDelayTimer = setTimeout(() => {\n          node.delayOccured = true\n        }, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n      } else {\n        node.delayOccured = true\n      }\n    }\n\n    node.initializeInputDelayTimer()\n\n    node.on('input', function (msg) {\n      /* istanbul ignore next */\n      if (mbBasics.invalidPayloadIn(msg)) {\n        verboseWarn('Invalid message on input.')\n        return\n      }\n      /* istanbul ignore next */\n      if (node.isNotReadyForInput()) {\n        verboseWarn('Inject while node is not ready for input.')\n        return\n      }\n      /* istanbul ignore next */\n      if (modbusClient.isInactive()) {\n        verboseWarn('You sent an input to inactive client. Please use initial delay on start or send data more slowly.')\n        return\n      }\n\n      const origMsgInput = Object.assign({}, msg) // keep it origin\n      try {\n        const inputMsg = node.prepareMsg(origMsgInput)\n        if (node.isValidModbusMsg(inputMsg)) {\n          const newMsg = node.buildNewMessageObject(node, inputMsg)\n          node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, inputMsg, newMsg))\n          modbusClient.emit('readModbus', newMsg, node.onModbusReadDone, node.onModbusReadError)\n        }\n      } catch (err) {\n        node.errorProtocolMsg(err, origMsgInput)\n        mbBasics.sendEmptyMsgOnFail(node, err, origMsgInput)\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      node.resetInputDelayTimer()\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-flex-getter', ModbusFlexGetter)\n}\n"]}