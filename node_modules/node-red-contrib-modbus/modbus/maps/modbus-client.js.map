{"version":3,"sources":["modbus-client.js"],"names":["module","exports","RED","install","mbBasics","require","coreModbusClient","nodes","registerType","this","config","ModbusRTU","defaultTcpUnitId","reconnectTimeMS","serverInfo","clienttype","undefined","bufferCommands","failureLogEnabled","tcpHost","stateLogEnabled","tcpPort","serialPort","serialBaudrate","serialDatabits","serialParity","serialType","serialConnectionDelay","parseInt","serialAsciiResponseStartDelimiter","unit_id","commandDelay","clientTimeout","timeoutTimeMS","serialConnectionDelayTimeMS","reconnectTimeout","parallelUnitIdsAllowed","reconnectOnTimeout","showWarnings","showLogs","node","isFirstInitOfConnection","bufferCommandList","showErrors","sendingAllowed","Map","unitSendingAllowed","verboseWarn","logMessage","settings","verbose","stateLog","actualServiceStateBefore","actualServiceState","state","value","stateMachine","stateService","reconnectTimeoutId","messageAllowedStates","serialSendingAllowed","coreModbusQueue","queueSerialLockCommand","setDefaultUnitId","createStateMachineService","initialState","defaultUnitId","startStateService","setUnitIdFromPayload","unitId","client","msg","Number","minCommandDelayMilliseconds","checkUnitId","updateServerinfo","errorProtocolMsg","queueLog","verboseLog","err","matches","queueLogEnabled","subscribe","setTimeout","connectClient","initQueue","send","logHintText","emit","queueSerialUnlockCommand","checkQueuesAreEmpty","dequeueCommand","close","payload","connectC701","setTCPConnectionOptions","message","port","modbusErrorHandling","then","error","Error","autoOpen","modbusTcpErrorHandling","connectTelnet","connectTcpRTUBuffered","serialPortOptions","baudRate","serialStopbits","connectTCP","connectAsciiSerial","e","modbusSerialErrorHandling","connectRTU","setSerialConnectionOptions","dataBits","stopBits","parity","setID","setTCPConnected","startOfSlaveFrameChar","toString","errno","networkErrors","includes","connectRTUBuffered","modbusSerialDebug","openSerialClient","JSON","stringify","cb","isInactive","cberr","code","on","pushToQueueByUnitId","queueLength","onModbusClose","Promise","reject","customModbusMessage","resolve","readModbus","info","setMaxListeners","unlimitedListeners","get","queueUnitId","length","invalidPayloadIn","nodeIdentifierName","closingModbus","writeModbus","internalDebugLog","isOpen","activateSending","removeAllListeners","done","registeredNodeList","registerForModbus","clientUserNodeId","Object","setStoppedState","internalDebug","setNewNodeSettings","name","id","closeConnectionWithoutRegisteredNodes","SerialPort","keys","deregisterForModbus","_","isUndefined","indexOf","isActive","isReadyToSend","httpAdmin","auth","needsPermission","req","res","list","ports","json"],"mappings":"AAcAA,OAAAC,QAAA,SAAAC,GAEAF,QAAOC,oBAAuB,EAAEE,QAAA,EAC9B,IAAAC,EAAYC,QAAA,iBAAA,EAGNC,EAAmBD,QAAQ,2BAA2B,EAF5DA,EAAQA,QAAsBF,0BAAS,EACjCC,EAAmBC,QAAA,OAAiB,EAAC,6BAAA,EACrCC,EAAAA,QAAAA,YAA0B,EAguBhCJ,EAAIK,MAAMC,aAAa,gBA9tBvB,SAAyBH,GACzBH,EAAOK,MAAGF,WAAQI,KAAaC,CAAA,EAM7B,IAAMC,EAAYN,QAAQ,0BAA0B,EAK9CO,EAAoB,IAGpBC,EAAe,gCAqDhBC,GAjDLL,KAAKM,WAAaL,EAAOK,WAGGC,KAAAA,IAA1BN,EAAKO,uBACNR,KAAMQ,eAAA,CAAA,EAEPR,KAAAQ,eAAAP,EAAAO,eAIAR,KAAKS,gBAAiBR,EAAGA,gBAEzBD,KAAKU,gBAAiBA,EAAOC,gBAC7BX,KAAKY,kBAAmBX,EAAOW,kBAG/BZ,KAAKa,QAAUZ,EAAGA,QAClBD,KAAKc,QAAAA,SAAiBb,EAAOa,OAAAA,GAAc,IAC3Cd,KAAKe,QAAAA,EAAiBd,QAEtBD,KAAKgB,WAAYf,EAAGA,WACpBD,KAAKiB,eAAahB,EAAOgB,eACzBjB,KAAKkB,eAAAA,EAAwBC,eAC7BnB,KAAKoB,eAAAA,EAAAA,eAELpB,KAAKqB,aAAUF,EAASlB,aACxBD,KAAKsB,WAAYrB,EAAGkB,WACpBnB,KAAKuB,sBAAwBJ,SAAQI,EAAAA,qBAAkBC,GAAaC,EACpEzB,KAAK0B,kCAAmCA,EAAAA,mCA/BpB,OAkCpB1B,KAAIC,QAAO0B,SAAAA,EAAAA,OAA2BpB,EALtCP,KAMEsB,aAAKK,SAAsB1B,EAAOqB,YAAA,GA1CR,EA2C5BtB,KAACuB,cAAMJ,SAAAlB,EAAAsB,aAAA,GAvCDE,IAkCNzB,KAME0B,iBAAKC,SAAyB1B,EAAO0B,gBAAAA,GAvCb,IAwC1B3B,KAAA4B,mBAAA3B,EAAA2B,mBAG2BC,KAAAA,IAAvB5B,EAAC4B,uBACL7B,KAAK8B,uBAA0B,CAAA,EAG/BC,KAAKC,uBAA0B/B,EAAI0B,uBAGnCI,KAAKE,WAAAA,EAAoBC,WACzBH,KAAKI,aAAclC,EAAOmC,aAC1BL,KAAKM,SAAAA,EAAkBP,SAElBzB,MA4CL,SAgBEiC,EAAAC,GACF9C,EAAA+C,SAAAC,SAAAV,EAAAF,eAEAE,EAASW,iBAAUH,EACjBR,EAAIA,KAAKpB,aAAiB4B,EAAA,IAAAR,EAAA1B,UAAA,EAf5B,CAQA,SAmBOsC,EAAAA,GACDlD,EAACmD,SAAAA,SAAqBC,EAAKf,UAC/BY,EAAeI,cAAM,aAAAP,EAAA,IAAAR,EAAA1B,UAAA,CAjBvB,CA3DA0B,EAAKgB,wBAAmB,CAAA,EACxBhB,EAAKiB,cAAe,CAAA,EACpBjB,EAAKgB,OAAAA,KACLhB,EAAKa,kBAAkB,IAAGb,IAC1BA,EAAKY,eAAAA,IAAAA,IACLZ,EAAKiB,mBAAenD,GACpBkC,EAAKkB,qBAAsBpD,EAAAqD,qBAC3BnB,EAAKoB,WAAAA,GAGLC,EAAAA,aAAgBC,KAEhBtB,EAAKuB,aAAAA,KAVLvB,EAWEgB,aAASzC,EAAsBiD,0BAAA,EAVjCxB,EAWIA,mBAAe5B,EAAAA,aAAgBqD,aAVnCzB,EAWGY,yBAAMZ,EAAAa,mBAVTb,EAWIA,aAAe0B,EAAaC,kBAAA3B,EAAAgB,YAAA,EAVhChB,EAWEkB,mBAAA,EACFlB,EAACoB,qBAAA,CAAA,EAEDpB,EAAK4B,iBAAAA,EAVLP,EAYOvD,uBAA6B+D,CAAM,EAV1C7B,EAYEuB,iBAAA,WACwB,QAApBtD,KAAC6D,WACLC,EAAIF,QArFiB,EAwFnBG,EAAAA,QAzFEC,CA2FN,EAXAjC,EAcE4B,qBAAwB,SAAOG,GAb/B,IAcMF,EAACvD,EAAuB0B,gBAAkBA,EAAGA,CAAKnB,EACvDf,EAAMoE,YAAAL,EAAA7B,EAAAzB,UAAA,GACLyB,EAAK1B,iBAAa,EAEpB0B,EAAK1B,OAAAA,MAAUuD,CAAI,EACpBE,EAAAF,OAAAA,CACD,EAEEG,CAAAA,OAAQvB,MAAAA,EAASC,OAAO,GAASZ,EAAcoC,YAAAlC,EAAAV,QAAAU,EAAAzB,UAAA,GAb/CyB,EAcEA,iBAAKmC,EAGTnC,EAAAmC,iBAAA,WAEwB,QAAnBC,EAAAA,WACHpC,EAAIA,WAAe,QAAEA,EAAArB,QAAA,IAAAqB,EAAAnB,QAErBmB,EAAA1B,WAAA,WAAA0B,EAAAlB,WAAA,IAAAkB,EAAAjB,eAAA,QAGFiB,EAAA1B,YAAqBkC,qBAAYR,EAAAV,OAfjC,EA2BAU,EAAKqC,iBAAW,SAAU7B,EAAYuB,GAChC/B,EAAKvB,YACP6D,EAAAA,YAAqBtC,EAACuC,EAAAR,CAAA,CAE1B,EAJA/B,EAsBEqC,SAAUG,SAAchC,GACtBR,EAAAvB,gBAAAuB,EAAAyC,iBACAlC,EAAWC,CAAC,CApBhB,EAEAR,EAuBIiB,aAAIyB,UAAA,SAAA5B,GAnCR,IAoBIN,EAHF,GAJAR,EAuBIY,yBAASX,EAAuBY,mBAtBpCb,EAAKa,mBAuBMZ,EAjBTO,EAkBIM,EAAAC,MAjBNf,EAAApB,iBAEA0D,EAAS1B,CAAAA,EANJE,EAuBC6B,OAA+BjD,KAAAA,IAApBM,EAAK4C,mBAAelD,OAMjCM,EAAAY,yBAAYG,QAAAf,EAAAa,mBAAAE,MAvBhB,CAKA,GAqBED,EAAA0B,QAAA,MAAA,EAAA,CAGFjC,EAAA,wBAAAP,EAAAY,yBAAAG,KAAA,EAEAf,EAAIc,iBAAc,EAChBO,EAAAwB,UAAA7C,CAAA,EACAO,EAAAA,mBAAY,EAEZP,IACFA,EAAAC,yBAEIa,EAAM0B,wBAAsB,CAAA,EAE1BxC,EAAKvB,0BAA8D,EACrEuB,WAAKiB,EAAa6B,cAAapD,CAAA,IAI/BoB,EAAc,eAAad,EAAAL,iBAAA,KAAA,EACzBK,WAAKzB,EAAUqE,cAAY5C,EAAAL,gBAAA,EApB/B,CAsBC,MAAM4C,GAvBLvC,EAyBEqB,MAAAA,EAAAA,CAAgBC,QAAAA,2BAA4ByB,CAAA,CAAA,CAxBhD,CA2BA/C,EAAAgD,KAAA,QAAA,CACF,CAGEL,EAAAA,QAAW,WAAM,IAEjBpC,EAAQhB,6BAAaS,EAAAY,yBAAAG,MAAAgC,CAAA,EACrB/C,EAAUiD,yBAAUjD,CAAA,EACtBA,EAAAgD,KAAA,aAAA,GAIEhD,EAAKgD,QAAK,WAAS,IACrBhD,EAAAgD,KAAA,UAAA,EAEIlC,EAAM0B,iBAAmB,CAAAnB,EAAA6B,oBAAAlD,CAAA,GAC3BA,EAAKgD,aAAeF,KAAC,OAAA,EAIvBhC,EAAA0B,QAAA,UAAA,IAC0B,QAAtB1B,EAAM0B,WACRxC,EAAKgD,aAAeF,KAAC,MAAA,EAEvB9C,EAAAoB,uBAEIN,EAAcQ,uBAAYtB,CAAA,EAC5BA,EAAAiB,aAAA6B,KAAA,MAAA,IAMAhC,EAAA0B,QAAA,SAAA,IACAjC,WAAW,WACXP,EAAUmD,eAAWnD,CAAA,CACrBA,EAAAA,EAAKiB,YAAa6B,EACpB9C,EAAAgD,KAAA,SAAA,GAIEzC,EAAAA,QAAY,QAAA,IACZP,EAAUiD,yBAAYjD,CAAA,EACtBA,EAAIA,KAAKH,QAAAA,GAGPG,EAAKiB,QAAAA,QAAiB,IACxBjB,EAAAgD,KAAA,UAAA,EACFhD,EAAAiB,aAAA6B,KAAA,OAAA,GAKEzB,EAAAA,QAAgBC,QAAAA,IAChBtB,EAAKgD,KAAK,UAAA,EACVhD,EAAIA,aAAKL,KAAAA,WAAuB,GAGhCgD,EAAAA,QAAW,SAAM,IA9BjBpC,EAgCOU,oCAAyB,EAChCjB,EAAGA,KAAKL,UAAAA,GAIPiD,EAAAA,QAAa,QAAG,IAEjBrC,EAASuB,0BAAQ9B,EAAAY,yBAAAG,MAAAgC,CAAA,EAhCjB/C,EAiCEgD,KAAI,UAAA,2BAAAhD,EAAAY,yBAAAG,MAAAgC,CAAA,EAhCN/C,EAiCIA,aAAYoD,KAAM,OAAA,GA9BpBtC,EAiCEwB,QAAW,QAAA,IA/Bf/B,EAiCI+B,0BAAuBtC,EAAAY,yBAAAG,MAAAgC,CAAA,EAhC3B/C,EAiCEgD,KAAA,WAAA,0BAAAhD,EAAAY,yBAAAG,MAAAgC,CAAA,EACF/C,EAAAH,mBACAG,EAAK8B,aAAagB,KAAA,WAAA,EAGlB9C,EAAK8B,aAAUgB,KAAS,UAACP,GAKzBzB,EAAKd,QAAKR,cAAe,IAEzBe,EAAA,6BAAAP,EAAAY,yBAAAG,MAAAgC,CAAA,EAEA1B,EAAU1B,uBAAkBK,CAAA,EAnC5BA,EAoCEA,KAAKL,gBAAmBtB,EAC1B2B,EAAAL,kBAAA,IAEAK,EAAIA,iBA9RkB,KA2PtB2C,WAqCO7E,WApCLkC,EAqCEA,mBAAqB,EApCvBA,EAoCoDqD,aAAc/D,KAAAA,MAAAA,CAnCpE,EAAGU,EAmC2EL,gBAAA,EAlJhF,CAiHF,CAAC,EAEDK,EAAK4C,cAoCK,WAnCR,IACE,GAAI5C,EAoCE8B,OAnCJ,IACE9B,EAoCIA,OAAK8B,MAAOwB,WAnCdhB,EAoCUtC,mBAAY,CAnCxB,CAAC,EACDsC,EAoCW,uBAAMiB,CAjCnB,CAFE,MAsCQvD,GArCRsC,EAsCQC,EAAOiB,OAAK,CArCtB,CAkBF,GAhBAxD,EAAK8B,OAsCM,KArCX9B,EAAK8B,OAsCGQ,IAAUnE,EApClB6B,EAAK8B,OAsCK2B,GAAI,QAAO5E,SAAAA,GArCnBmB,EAAK0D,oBAsCanB,CAAA,EArClB3E,EAsCS+F,gBAAUJ,QAAAA,CAAAA,CArCrB,CAAC,EAEIvD,EAuCOR,gBAtCVQ,EAAKR,cAxRLE,KA2RGM,EAuCGsC,mBAtCNtC,EAAKL,iBA3Re,KAqUD4D,QAvCjBvD,EAuCKzB,WAAYgF,CArCnB,GAAI,CAACzF,EAwCiBoE,YAAAlC,EAAAV,QAAAU,EAAAzB,UAAA,EArCpB,OAFAyB,EAwCO4D,MAAC,IAAAC,MAAA,wBAAA,EAAA,CAAAR,QAAArD,EAAAV,OAAA,CAAA,EAvCRU,EAwCIiB,aAAA6B,KAAA,SAAA,EACF,CAAA,EArCJ,IACE,OAwCMgB,EAAAA,SAvCJ,IAwCKH,OAvCHrB,EAyCSyB,sBAA0B,EAxCnC/D,EAyCI8B,OAAOwB,YAAKtD,EAAArB,QAAA,CACZ8E,KAAAzD,EAAAnB,QACRiF,SAAA,CAAA,CACA,CAAA,EAAAH,KAAA3D,EAAAuD,uBAAqC,EAChCQ,KAAAA,EAAAA,eAAyB,EAAA,MAClB,SAAAxB,GAET,OADLvC,EAAA+D,uBAAAxB,CAAA,EACK,CAAA,CACL,CAAA,EACKzE,MACHkC,IAAK4D,SAAoDP,EAAa,aAAC/D,EAAUU,EAAA8B,OAAAkC,cAAAhE,EAAArB,QAAA,CAC5EsC,KAAAA,EAAYpC,QACjBiF,SAAY,CAAA,CACd,CAAA,EAAAH,KAAA3D,EAAAuD,uBAAA,EAAA,MAEUpE,SAAAA,GAEV,OADOA,EAAAA,uBAAwBO,CAAAA,EAC/B,CAAA,CAEKM,CAAI,EACH,MAAoE,IAAA,mBACpEsC,EAACrB,uBAA4B,EACjCjB,EAAO8B,OAAKmC,sBAAAjE,EAAArB,QAAA,CACd8E,KAAAzD,EAAAnB,QAEMqF,SAAAA,CAAAA,CACJC,CAAAA,EAAAA,KAAU/E,EAAAA,uBAA6B,EAAA,MAC7BA,SAAAA,GAEFY,OADAA,EAAEZ,uBAAcgF,CAAe,EAC1BnF,CAAAA,CACb6E,CAAAA,EACD,MAEG,QACFxB,EAAapD,UAAU,EACrBc,EAAK8B,OAAOuC,WAAArE,EAAArB,QAAA,CACV2D,KAAAA,EAAWzD,QACXiF,SAAA,CAAA,CACA,CAAA,EAAAH,KAAQ3D,EAACX,uBAAAA,EAAAA,MACP6E,SAAAA,GAEAA,OADDlE,EAAM+D,uBAAAxB,CAAA,EACL2B,CAAAA,CACF,CAAA,CAxCJ,CAIF,CAuCkBI,MAAkBC,GAxClC,OADAvE,EAAK+D,uBA2CQS,CAAAA,EACL,CAAA,CA1CV,CACF,KAAO,CAEL,GAAI,CAAC1G,EA2CYoE,YAAiBlC,EAACV,QAAAU,EAAAzB,UAAA,EAxCjC,OAFAyB,EA2CIA,MAAK8B,IAAM+B,MAACY,+BAA4BP,EAAAA,CAAAA,QAAmBP,EAAK3D,OAAK0E,CAAAA,EA1CzE1E,EAAKiB,aA4CQuD,KAAAA,SAAAA,EACL,CAAA,EArCV,GAwCIxE,EAAAb,wBA3CFa,EA4CIsC,sBAAW5C,GAzCb,CAACM,EA6CKlB,WAGR,OA/CAkB,EA6CO4D,MAAC,IAAAC,MAAA,mBAAA,EAAA,CAAAR,QAAArD,EAAAlB,UAAA,CAAA,EA5CRkB,EA6CIiB,aAAA6B,KAAA,SAAA,EACJ,CAAA,EA1CF,IA6CEoB,EAAY,CACdC,SAAA/E,SAAAY,EAAAjB,cAAA,EACF4F,SAAAvF,SAAAY,EAAAhB,cAAA,EACA4F,SAAAxF,SAAAY,EAA2BoE,cAAY,EACnCS,OAACnB,EAAAA,aACLI,SAAY,CAAA,CACd,EAGD,IAEIP,OAAAA,EAAAA,YACEzB,IAAOgD,QACPhD,EAAOa,mBAAgBnD,EAE7BQ,EAAAX,mCAAA,UAAA,OAAAW,EAAAX,kCAEI0F,EAAkBC,sBAAY5F,SAAAY,EAAAX,kCAAA,EAAA,EAElC6E,EAAAc,sBAAAhF,EAAAX,kCAGM4B,EAAa6B,+BAAkBoB,EAAAc,sBAAAC,SAAA,EAAA,CAAA,EAErCjF,EAAA8B,OAAAwC,mBAAAtE,EAAAlB,WAAAoF,CAAA,EAAAP,KAAA3D,EAAA0E,0BAAA,EAAA,MAEIhB,SAAAA,GAEKF,OADRnC,EAAgB4B,0BAA6BV,CAAC,EAC7B,CAAA,CACfzE,CAAAA,EACK,MACLA,IAAAA,MACFwE,EAAA,iBAAA,EACQ4C,EAAKpD,OAAIhE,WAAgBkC,EAACmF,WAAcC,CAAmB,EAAEzB,KAAA3D,EAAA0E,0BAAA,EAAA,MAClD,SAAC5B,GAErB,OADC9C,EAAAwE,0BAAAjC,CAAA,EACD,CAAA,CAEIwB,CAAAA,EACH1C,MACQ,QACDuC,EAAU,0BAAA,EACjB5D,EAAA8B,OAAAuD,mBAAArF,EAAAlB,WAAAoF,CAAA,EAAAP,KAAA3D,EAAA0E,0BAAA,EAAA,MAEShG,SAAAA,GAELZ,OADM0F,EAASgB,0BAAAjC,CAAA,EACE+C,CAAAA,CACZ,CAAA,CAEP,CAMF,CALA,MAAAf,GAIM,OAFDhC,EAAI2C,0BAA0BC,CAAAA,EAE5BlE,CAAAA,CACP,CACD,CAlDC,CAoD4B,MAAGsB,GAE/B,OADAlB,EAAAA,oBAAgB4B,CAAAA,EACP9C,CAAAA,CAtDT,CA0DA,MAAIH,CAAAA,CAvDN,EAEAA,EAwDKuD,wBAAM,WAvDTvD,EAwDIlC,OAAAA,MAAAA,EAAiBwH,OAAAA,EAvDrBtF,EAwDE8B,OAAAa,WAAA3C,EAAAR,aAAA,EACFQ,EAAAiB,aAAA6B,KAAA,SAAA,CAvDF,EA4DA9C,EAAKuF,gBAAgB,WACnBzH,EAAAwH,kBAAA,2BAAAtF,EAAArB,OAAA,CAzDF,EAEAqB,EA0DIlC,2BAAiBwH,WAzDnBtF,EA0DEA,aAAY8E,KAAM9E,YAAa,EAzDjC2C,WA0DOb,EAAOa,iBAAoB3C,SAAKR,EAAAA,qBAAe,CAAA,CAzDxD,EAEAQ,EA0DG0D,oBAAM,SAAAnB,GAzDPlB,EA0Da4B,yBAAAjD,CAAgC,EAC3ClC,EAAAA,QACAkC,EAAiBsF,kBAAc,uBAAA/C,EAAAiB,OAAA,EAElC1F,EAAAwH,kBAAA,uBAAAE,KAAAC,UAAAlD,CAAA,CAAA,EAGClB,EAAAA,OAAgB4B,EAAAA,cAA8BmC,SAAA7C,EAAA2C,KAAA,GAC9ClF,EAAAiB,aAAA6B,KAAA,SAAA,CAzDF,EA6DA9C,EAAC+D,uBAAA,SAAAxB,GAEDvC,EAAQiD,yBAAiClB,CAAK2D,EAC5C1F,EAAAG,YACArC,EAAAA,MAAAA,CAAgB,EAIVgD,EAAKpC,oBACPsB,EAAK2F,QACPC,EAAgBN,kBAAA,0BAA6CvE,EAAQgB,OAAI,EAEzEjE,EAASW,kBAAgB,0BAAA+G,KAAAC,UAAAlD,CAAA,CAAA,IAzDtBA,EA6DGiB,OAASzB,EAAWoD,cAAAC,SAAA7C,EAAA2C,KAAA,GA5DzB3C,EAAIsD,MA6DQ/E,EAAWqE,cAAAC,SAAA7C,EAAAsD,IAAA,IA5DxB7F,EAAKiB,aA6DY6B,KAAM,OAAC5C,CA3D5B,EAEAF,EAAKwE,0BA6DwB,SAAAjC,GA5D3BlB,EA6DWJ,yBAA0BjB,CAAA,EACjCA,EAAEG,YACJH,EAAC4D,MAAMrB,CAAA,EAGTvC,EAAAtB,oBACA6D,EAAAiB,QAEGsC,EAAkBR,kBAAiB,6BAAS/C,EAAAiB,OAAA,EAG3CxD,EAAiBsF,kBAAE,6BAAAE,KAAAC,UAAAlD,CAAA,CAAA,GA3DvBvC,EA+DIqB,aAAAA,KAAgB0E,OAAAA,CA9DtB,EAEA/F,EAAKuF,iBA+DkBlC,WAEKnD,WA/DtBF,EA+DIgG,mBAAkB9F,OA9DxBoC,EA+DO,qBAAAtC,EAAAV,OAAA,EA9DPxB,EA+DWwH,kBAAe,0BAAA,EA9D1BtF,EA+DI4F,OAAMrD,MAAQvC,EAACV,OAAA,EA9DnBU,EA+DI8B,OAAAa,WAASvD,SAAYY,EAAAR,aAAA,CAAA,EA9DzBQ,EA+DIA,OAAKiB,MAAAA,GAAY,QAAMjB,EAAQiG,aAAA,EA9DnCjG,EA+DIiB,aAAA6B,KAAA,SAAA,IA7DJR,EA+DExE,iCAA4C8H,EAAK/E,mBAACE,KAAA,EACpDjD,EAAAwH,kBAAA,2CAAAtF,EAAAa,mBAAAE,KAAA,EACFf,EAAAiB,aAAA6B,KAAA,OAAA,EAGF9C,EA9DAA,EAgEEqB,cAAgB4B,WAEhB5B,EAAW6E,yBACUC,CAAM,EAhE3B5F,EAkEc,oBAAiB,EAjE/BzC,EAkEauE,kBAAwB,oBAAA,EAjErCrC,EAAKiB,aAkEW6B,KAAA,OAAA,CAjElB,EAEA9C,EAAK8F,GAAG,sBAkEwB,SAAO1E,EAAAA,EAAAA,GAhErCtD,EAkEWsI,oBAAApG,EAAA+B,EAAA2D,EAAAE,CAAA,CAjEb,CAAC,EAED5F,EAAK8F,GAmEK,aAAA,SAAA/D,EAAA2D,EAAAE,GAlER,IAmEM9E,EAAAd,EAAAa,mBACAwF,EAAAA,WAAS,EACXT,EAAE,IAAOrD,MAAK,qCAAAzB,EAAAC,KAAA,EAAAgB,CAAA,EAEd/B,EAAAvB,eACA4C,EAAA0E,oBAAA/F,EAAAlC,EAAAwI,WAAAvE,EAAA2D,EAAAE,CAAA,EAAAjC,KAAA,WACL3D,EAAAqC,SAAAmD,KAAAC,UAAA,CAESc,KAAC,kBACNC,QAAAA,EAAgBC,QAEb3F,MAAAA,EAAaC,MACdE,YAAa6B,EAAK5C,kBAAQwG,IAAA3E,EAAA4E,WAAA,EAAAC,MAC/B,CAAA,CAAA,CAEGd,CAAE,EAAC,MAAA,SAAAvD,GACF3E,EAAQ2E,EAACsE,CAAAA,CACX,CAAA,EAAA,QAAUhD,WACZ7D,EAAAiB,aAAA6B,KAAA,OAAA,CAEAhF,CAAAA,EAEIA,EAAKwI,WAAAtG,EAAA+B,EAAA2D,EAAAE,CAAA,CApEX,CAAC,EAED5F,EAuEEA,GAAKiB,cAAa6B,SAAaf,EAAC2D,EAAAE,GAChC,IAAA9E,EAAAd,EAAAa,mBAGMiG,EAAAA,WAAAA,EACN9G,EAAK+G,IAAAA,MAAa,sCAAOjG,EAAAC,KAAA,EAAAgB,CAAA,EAEpBd,EAAAA,eACLqB,EAAWyD,oBAAgBe,EAAmBhJ,EAAAkJ,YAAAjF,EAAA2D,EAAAE,CAAA,EAAAjC,KAAA,WACzCsD,EAAAA,SAAAA,KAAiBxB,UAAa,CAE3Bc,KAACzE,mBACH9B,QAAW+B,EAACmF,QACVpG,MAAOA,EAAMC,MACfiF,YAAShG,EAAAE,kBAAAwG,IAAA3E,EAAA4E,WAAA,EAAAC,MAxET,CAAC,CAyEC,CAxEJ,CAAC,EAAC,MAyEEtE,SAAWC,GACbqD,EAACrD,EAAMR,CAAA,CAxET,CAAC,EAAC,QAyEE,WAxEF/B,EAyEEsC,aAAWQ,KAAA,OAAA,CAxEf,CAAC,EA2EDhF,EAAEkJ,YAAAhH,EAAA+B,EAAA2D,EAAAE,CAAA,CAtER,CAAC,EAED5F,EAyEImH,gBAAA,SAAApF,GArEF,OAHA/B,EA0EEA,eAAYoH,IAAAA,EAAAA,YAAoB,CAAA,CAAA,EAClC/F,EAAO4B,yBAAAjD,CAAA,EAELsC,IAAAA,QACA+E,SAAMhB,EAAAF,GACR,IAEKiB,EAAAA,iBACLpH,EAAAqC,SAAAmD,KAAAC,UAAA,CA1EUc,KAAM,kCA4ElBP,YAAAhG,EAAAE,kBAAA0G,OACKU,eAAuBtH,EAAAI,eAAAsG,IAAA3E,EAAA4E,WAAA,EAEvBY,qBAAoBvH,EAAUwH,qBAC5BF,YAAkBvF,EAACyF,WACpBC,CAAAA,CAAM,EAEHxG,EAAkBiC,oBAAMlD,CAAA,IACxBiB,EAAAA,aAAkB6B,KAAO,OAAA,EAGjCuD,EAAA,CAIK,CAFDqB,MAAAA,GACEzG,EAAAA,CAAAA,CACD,CACJoG,CAAAA,CACF,EA3EA/E,EA8EMmF,aAAiBH,EA7EvBtH,EA8EIA,gBAnqBsB,CAmqBG,EA5E7BA,EAAK8F,GA8EC,YAAe,WA7EnB9F,EAAKiB,aA8EamC,KAAK,OAAC,CA7E1B,CAAC,EAEDpD,EAAK8F,GA8EE,mBAAM,SAAA/D,EAAA2D,EAAAE,GA7EX,GAAIhI,EA8EO8J,iBAAgBF,CAAAA,EA7EzB,MA8EE,IAAA3D,MAAA,8BAAA,EA3EJ/F,EA8EE6J,cAAA,gCAAAnC,KAAAC,UAAA1D,EAAAsB,OAAA,CAAA,EACDvF,EAAM8J,mBAAA5H,EAAA+B,CAAA,EACL/B,EAAAA,CAAK0H,EAER9B,EAAA,IAAA/B,MAAA,8BAAA,EAAA9B,CAAA,EAGCjE,EAAI6J,cAAA,4CAAA3H,EAAAa,mBAAAE,KAAA,EA9EJf,EA+EEiB,aAAYqG,KAAAA,QAAAA,CA9EhB,CAAC,EAEDtH,EAAK8F,GA+EC9F,QAAU,SAAAqH,GA9Ed,IA+EGP,EAAM9G,EAAA6H,MAAA7H,EAAA8H,GA9ET9H,EA+EIA,cAAK+H,CAAAA,EA9ETzF,EA+EE,qBAAAwE,CAAA,EACF9G,EAAEiB,aAAY6B,KAAA,MAAA,EA9EdR,EA+EE,cAAAwE,CAAA,EA9EF9G,EA+EEO,iBAAgBiD,cAAUsD,CAA0BU,EAEpDH,EAAMvF,QACR9B,EAAA8B,OAAAoF,OACDlH,EAAA8B,OAAAsB,MAAA,SAAAb,GAIAD,EAFIqD,EAEJ,gCAAAmB,EAIA,0BAAAA,CAJA,EAOK9G,EAAKa,CACP,CAAA,GAIFyB,EAAY,yBAAAwE,CAAA,EACbO,EAAA,GAhFGrH,EAAK8B,OAAOsF,mBAAmB,IAuF7BY,EAAU,4BAAwBlB,CAAA,EACxCkB,EAAAA,GAGEhI,EAAAoH,mBAAA,CAnFF,CAAC,EAuFDpH,EAAEsH,mBAAA,GAELtH,EAAAuH,kBAAA,SAAAC,GAnFKxH,EAAKsH,mBAAmBE,GAAoBA,EACQ,IAAhDC,OAAOQ,KAAKjI,EAAKsH,kBAAkB,EAAEV,SACvC5G,EAAK+G,cAAgB,CAAA,EACrB/G,EAAKiB,aAAa6B,KAAK,KAAK,EAC5B9C,EAAKiB,aAAa6B,KAAK,MAAM,GAE/B9C,EAAKgD,KAAK,aAAcwE,CAAgB,CAC1C,EAEAxH,EAAK0H,gBAAkB,SAAUF,EAAkBH,GACjDrH,EAAKiB,aAAa6B,KAAK,MAAM,EAC7B9C,EAAKgD,KAAK,eAAgBwE,CAAgB,EAC1CH,EAAK,CACP,EAEArH,EAAK+H,sCAAwC,SAAUP,EAAkBH,GACnB,IAAhDI,OAAOQ,KAAKjI,EAAKsH,kBAAkB,EAAEV,SACvC5G,EAAK+G,cAAgB,CAAA,EACjB/G,EAAK8B,SAA4C,YAAlC9B,EAAKa,mBAAmBE,OACrCf,EAAK8B,OAAOoF,OACdlH,EAAK8B,OAAOsB,MAAM,WAChBpD,EAAK0H,gBAAgBF,EAAkBH,CAAI,CAC7C,CAAC,EAQLrH,EAAK0H,gBAAgBF,EAAkBH,CAAI,CAE/C,EAEArH,EAAKkI,oBAAsB,SAAUV,EAAkBH,GACrD,IACE,OAAOrH,EAAKsH,mBAAmBE,GAC3BxH,EAAK+G,eACPM,EAAK,EACLrH,EAAKgD,KAAK,eAAgBwE,CAAgB,GAE1CxH,EAAK+H,sCAAsCP,EAAkBH,CAAI,CAOrE,CALE,MAAO9E,GAEPhC,EAAYgC,EAAIiB,QAAU,wBAA0BgE,CAAgB,EACpExH,EAAK4D,MAAMrB,CAAG,EACd8E,EAAK,CACP,CACF,EAEArH,EAAK2F,WAAa,WAChB,OAAOwC,EAAEC,YAAYpI,EAAKa,kBAAkB,GAA0E,CAAC,IAAtEb,EAAKmB,qBAAqBkH,QAAQrI,EAAKa,mBAAmBE,KAAK,CAClH,EAEAf,EAAKsI,SAAW,WACd,MAAO,CAACtI,EAAK2F,WAAW,CAC1B,EAEA3F,EAAKuI,cAAgB,SAAUvI,GAC7B,MAAA,EAAIA,CAAAA,EAAKa,mBAAmB2B,QAAQ,UAAU,GAAKxC,CAAAA,EAAKa,mBAAmB2B,QAAQ,WAAW,IAI9FjC,EAAY,0BAA0B,EAC/B,GACT,CACF,CAEwD,EAGxD7C,EAAI8K,UAAU9B,IAAI,uBAAwBhJ,EAAI+K,KAAKC,gBAAgB,aAAa,EAAG,SAAUC,EAAKC,GAC7E/K,QAAQ,YAAY,EAC5BmK,WAAWa,KAAK,EAAElF,KAAK,SAAAmF,GAChCF,EAAIG,KAAKD,CAAK,CAChB,CAAC,EAAC,MAAO,SAAAvG,GAEPqG,EAAIG,KAAK,CAACxG,EAAIiB,QAAQ,EAEtB1F,EAAiB6J,cAAcpF,EAAIiB,OAAO,CAC5C,CAAC,CACH,CAAC,CACH","file":"../modbus-client.js","sourcesContent":["/**\n Copyright (c) since the year 2016 Klaus Landsdorf (http://plus4nodered.com/)\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\n All rights reserved.\n node-red-contrib-modbus\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n\n/**\n * Modbus connection node.\n * @module NodeRedModbusClient\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusClient = require('./core/modbus-client-core')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:config:client')\n  const _ = require('underscore')\n\n  function ModbusClientNode (config) {\n    RED.nodes.createNode(this, config)\n\n    // create an empty modbus client\n    const ModbusRTU = require('@open-p4nr/modbus-serial')\n\n    const unlimitedListeners = 0\n    const minCommandDelayMilliseconds = 1\n    const defaultUnitId = 1\n    const defaultTcpUnitId = 0\n    const serialConnectionDelayTimeMS = 500\n    const timeoutTimeMS = 1000\n    const reconnectTimeMS = 2000\n    const logHintText = ' Get More About It By Logging'\n    const serialAsciiResponseStartDelimiter = '0x3A'\n\n    this.clienttype = config.clienttype\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.bufferCommands = true\n    } else {\n      this.bufferCommands = config.bufferCommands\n    }\n\n    this.queueLogEnabled = config.queueLogEnabled\n    this.stateLogEnabled = config.stateLogEnabled\n    this.failureLogEnabled = config.failureLogEnabled\n\n    this.tcpHost = config.tcpHost\n    this.tcpPort = parseInt(config.tcpPort) || 502\n    this.tcpType = config.tcpType\n\n    this.serialPort = config.serialPort\n    this.serialBaudrate = config.serialBaudrate\n    this.serialDatabits = config.serialDatabits\n    this.serialStopbits = config.serialStopbits\n    this.serialParity = config.serialParity\n    this.serialType = config.serialType\n    this.serialConnectionDelay = parseInt(config.serialConnectionDelay) || serialConnectionDelayTimeMS\n    this.serialAsciiResponseStartDelimiter = config.serialAsciiResponseStartDelimiter || serialAsciiResponseStartDelimiter\n\n    this.unit_id = parseInt(config.unit_id)\n    this.commandDelay = parseInt(config.commandDelay) || minCommandDelayMilliseconds\n    this.clientTimeout = parseInt(config.clientTimeout) || timeoutTimeMS\n    this.reconnectTimeout = parseInt(config.reconnectTimeout) || reconnectTimeMS\n    this.reconnectOnTimeout = config.reconnectOnTimeout\n\n    if (config.parallelUnitIdsAllowed === undefined) {\n      this.parallelUnitIdsAllowed = true\n    } else {\n      this.parallelUnitIdsAllowed = config.parallelUnitIdsAllowed\n    }\n\n    this.showErrors = config.showErrors\n    this.showWarnings = config.showWarnings\n    this.showLogs = config.showLogs\n\n    const node = this\n    node.isFirstInitOfConnection = true\n    node.closingModbus = false\n    node.client = null\n    node.bufferCommandList = new Map()\n    node.sendingAllowed = new Map()\n    node.unitSendingAllowed = []\n    node.messageAllowedStates = coreModbusClient.messageAllowedStates\n    node.serverInfo = ''\n\n    node.stateMachine = null\n    node.stateService = null\n    node.stateMachine = coreModbusClient.createStateMachineService()\n    node.actualServiceState = node.stateMachine.initialState\n    node.actualServiceStateBefore = node.actualServiceState\n    node.stateService = coreModbusClient.startStateService(node.stateMachine)\n    node.reconnectTimeoutId = 0\n    node.serialSendingAllowed = false\n    node.internalDebugLog = internalDebugLog\n\n    coreModbusQueue.queueSerialLockCommand(node)\n\n    node.setDefaultUnitId = function () {\n      if (this.clienttype === 'tcp') {\n        node.unit_id = defaultTcpUnitId\n      } else {\n        node.unit_id = defaultUnitId\n      }\n    }\n\n    node.setUnitIdFromPayload = function (msg) {\n      const unitId = coreModbusClient.getActualUnitId(node, msg)\n      if (!coreModbusClient.checkUnitId(unitId, node.clienttype)) {\n        node.setDefaultUnitId()\n      }\n      node.client.setID(unitId)\n      msg.unitId = unitId\n    }\n\n    if (Number.isNaN(node.unit_id) || !coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n      node.setDefaultUnitId()\n    }\n\n    node.updateServerinfo = function () {\n      if (node.clienttype === 'tcp') {\n        node.serverInfo = ' TCP@' + node.tcpHost + ':' + node.tcpPort\n      } else {\n        node.serverInfo = ' Serial@' + node.serialPort + ':' + node.serialBaudrate + 'bit/s'\n      }\n      node.serverInfo += ' default Unit-Id: ' + node.unit_id\n    }\n    /* istanbul ignore next */\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose && node.showWarnings) {\n        node.updateServerinfo()\n        node.warn('Client -> ' + logMessage + ' ' + node.serverInfo)\n      }\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    function verboseLog (logMessage) {\n      if (RED.settings.verbose && node.showLogs) {\n        coreModbusClient.internalDebug('Client -> ' + logMessage + ' ' + node.serverInfo)\n      }\n    }\n\n    function stateLog (logMessage) {\n      if (node.stateLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.queueLog = function (logMessage) {\n      if (node.bufferCommands && node.queueLogEnabled) {\n        verboseLog(logMessage)\n      }\n    }\n\n    node.stateService.subscribe(state => {\n      node.actualServiceStateBefore = node.actualServiceState\n      node.actualServiceState = state\n      stateLog(state.value)\n\n      if (!state.value || node.actualServiceState.value === undefined) {\n        // verboseWarn('fsm ignore invalid state')\n        /* istanbul ignore next */\n        return\n      }\n\n      if (node.actualServiceStateBefore.value === node.actualServiceState.value) {\n        // verboseWarn('fsm ignore equal state ' + node.actualServiceState.value + ' after ' + node.actualServiceStateBefore.value)\n        return\n      }\n\n      if (state.matches('init')) {\n        /* istanbul ignore next */\n        verboseWarn('fsm init state after ' + node.actualServiceStateBefore.value)\n        node.updateServerinfo()\n        coreModbusQueue.initQueue(node)\n        node.reconnectTimeoutId = 0\n\n        try {\n          if (node.isFirstInitOfConnection) {\n            node.isFirstInitOfConnection = false\n            /* istanbul ignore next */\n            verboseWarn('first fsm init in ' + serialConnectionDelayTimeMS + ' ms')\n            setTimeout(node.connectClient, serialConnectionDelayTimeMS)\n          } else {\n            /* istanbul ignore next */\n            verboseWarn('fsm init in ' + node.reconnectTimeout + ' ms')\n            setTimeout(node.connectClient, node.reconnectTimeout)\n          }\n        } catch (err) {\n          /* istanbul ignore next */\n          node.error(err, { payload: 'client connection error ' + logHintText })\n        }\n\n        node.emit('mbinit')\n      }\n\n      if (state.matches('connected')) {\n        /* istanbul ignore next */\n        verboseWarn('fsm connected after state ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbconnected')\n      }\n\n      if (state.matches('activated')) {\n        node.emit('mbactive')\n        if (node.bufferCommands && !coreModbusQueue.checkQueuesAreEmpty(node)) {\n          node.stateService.send('QUEUE')\n        }\n      }\n\n      if (state.matches('queueing')) {\n        if (node.clienttype === 'tcp') {\n          node.stateService.send('SEND')\n        } else {\n          if (node.serialSendingAllowed) {\n            coreModbusQueue.queueSerialLockCommand(node)\n            node.stateService.send('SEND')\n          }\n        }\n      }\n\n      if (state.matches('sending')) {\n        setTimeout(() => {\n          coreModbusQueue.dequeueCommand(node)\n        }, node.commandDelay)\n        node.emit('mbqueue')\n      }\n\n      if (state.matches('opened')) {\n        coreModbusQueue.queueSerialUnlockCommand(node)\n        node.emit('mbopen')\n      }\n\n      if (state.matches('switch')) {\n        node.emit('mbswitch')\n        node.stateService.send('CLOSE')\n      }\n\n      /* istanbul ignore next */\n      if (state.matches('closed')) {\n        node.emit('mbclosed')\n        node.stateService.send('RECONNECT')\n      }\n\n      if (state.matches('stopped')) {\n        /* istanbul ignore next */\n        verboseWarn('stopped state without reconnecting')\n        node.emit('mbclosed')\n      }\n\n      if (state.matches('failed')) {\n        /* istanbul ignore next */\n        verboseWarn('fsm failed state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mberror', 'Modbus Failure On State ' + node.actualServiceStateBefore.value + logHintText)\n        node.stateService.send('BREAK')\n      }\n\n      if (state.matches('broken')) {\n        /* istanbul ignore next */\n        verboseWarn('fsm broken state after ' + node.actualServiceStateBefore.value + logHintText)\n        node.emit('mbbroken', 'Modbus Broken On State ' + node.actualServiceStateBefore.value + logHintText)\n        if (node.reconnectOnTimeout) {\n          node.stateService.send('RECONNECT')\n        } else {\n          node.stateService.send('ACTIVATE')\n        }\n      }\n\n      if (state.matches('reconnecting')) {\n        /* istanbul ignore next */\n        verboseWarn('fsm reconnect state after ' + node.actualServiceStateBefore.value + logHintText)\n        coreModbusQueue.queueSerialLockCommand(node)\n        node.emit('mbreconnecting')\n        if (node.reconnectTimeout <= 0) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n        setTimeout(() => {\n          node.reconnectTimeoutId = 0\n          node.stateService.send('INIT')\n        }, node.reconnectTimeout)\n      }\n    })\n\n    node.connectClient = function () {\n      try {\n        if (node.client) {\n          try {\n            node.client.close(function () {\n              verboseLog('connection closed')\n            })\n            verboseLog('connection close sent')\n          } catch (err) {\n            verboseLog(err.message)\n          }\n        }\n        node.client = null\n        node.client = new ModbusRTU()\n\n        node.client.on('error', (err) => {\n          node.modbusErrorHandling(err)\n          mbBasics.setNodeStatusTo('error', node)\n        })\n\n        if (!node.clientTimeout) {\n          node.clientTimeout = timeoutTimeMS\n        }\n\n        if (!node.reconnectTimeout) {\n          node.reconnectTimeout = reconnectTimeMS\n        }\n\n        if (node.clienttype === 'tcp') {\n          /* istanbul ignore next */\n          if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n            node.error(new Error('wrong unit-id (0..255)'), { payload: node.unit_id })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          try {\n            switch (node.tcpType) {\n              case 'C701':\n                verboseLog('C701 port UDP bridge')\n                node.client.connectC701(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .then(node.setTCPConnected)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'TELNET':\n                verboseLog('Telnet port')\n                node.client.connectTelnet(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              /* istanbul ignore next */\n              case 'TCP-RTU-BUFFERED':\n                verboseLog('TCP RTU buffered port')\n                node.client.connectTcpRTUBuffered(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n                break\n              default:\n                verboseLog('TCP port')\n                node.client.connectTCP(node.tcpHost, {\n                  port: node.tcpPort,\n                  autoOpen: true\n                }).then(node.setTCPConnectionOptions)\n                  .catch((err) => {\n                    node.modbusTcpErrorHandling(err)\n                    return false\n                  })\n            }\n          } /* istanbul ignore next */ catch (e) {\n            node.modbusTcpErrorHandling(e)\n            return false\n          }\n        } else {\n          /* istanbul ignore next */\n          if (!coreModbusClient.checkUnitId(node.unit_id, node.clienttype)) {\n            node.error(new Error('wrong unit-id serial (0..247)'), { payload: node.unit_id })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          if (!node.serialConnectionDelay) {\n            node.serialConnectionDelay = serialConnectionDelayTimeMS\n          }\n\n          if (!node.serialPort) {\n            node.error(new Error('wrong serial port'), { payload: node.serialPort })\n            node.stateService.send('FAILURE')\n            return false\n          }\n\n          const serialPortOptions = {\n            baudRate: parseInt(node.serialBaudrate),\n            dataBits: parseInt(node.serialDatabits),\n            stopBits: parseInt(node.serialStopbits),\n            parity: node.serialParity,\n            autoOpen: false\n          }\n\n          try {\n            switch (node.serialType) {\n              case 'ASCII':\n                verboseLog('ASCII port serial')\n                // Make sure is parsed when string, otherwise just assign.\n                if (node.serialAsciiResponseStartDelimiter && typeof node.serialAsciiResponseStartDelimiter === 'string') {\n                  serialPortOptions.startOfSlaveFrameChar = parseInt(node.serialAsciiResponseStartDelimiter, 16)\n                } else {\n                  serialPortOptions.startOfSlaveFrameChar = node.serialAsciiResponseStartDelimiter\n                }\n                verboseLog('Using response delimiter: 0x' + serialPortOptions.startOfSlaveFrameChar.toString(16))\n\n                node.client.connectAsciiSerial(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n              case 'RTU':\n                verboseLog('RTU port serial')\n                node.client.connectRTU(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n              default:\n                verboseLog('RTU buffered port serial')\n                node.client.connectRTUBuffered(node.serialPort, serialPortOptions).then(node.setSerialConnectionOptions)\n                  .catch((err) => {\n                    node.modbusSerialErrorHandling(err)\n                    return false\n                  })\n                break\n            }\n          } /* istanbul ignore next */ catch (e) {\n            node.modbusSerialErrorHandling(e)\n            return false\n          }\n        }\n      } /* istanbul ignore next */ catch (err) {\n        node.modbusErrorHandling(err)\n        return false\n      }\n\n      return true\n    }\n\n    node.setTCPConnectionOptions = function () {\n      node.client.setID(node.unit_id)\n      node.client.setTimeout(node.clientTimeout)\n      node.stateService.send('CONNECT')\n    }\n\n    node.setTCPConnected = function () {\n      coreModbusClient.modbusSerialDebug('modbus tcp connected on ' + node.tcpHost)\n    }\n\n    node.setSerialConnectionOptions = function () {\n      node.stateService.send('OPENSERIAL')\n      setTimeout(node.openSerialClient, parseInt(node.serialConnectionDelay))\n    }\n\n    node.modbusErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (err.message) {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + err.message)\n      } else {\n        coreModbusClient.modbusSerialDebug('modbusErrorHandling:' + JSON.stringify(err))\n      }\n      if (err.errno && coreModbusClient.networkErrors.includes(err.errno)) {\n        node.stateService.send('FAILURE')\n      }\n    }\n\n    node.modbusTcpErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (node.failureLogEnabled) {\n        if (err.message) {\n          coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + err.message)\n        } else {\n          coreModbusClient.modbusSerialDebug('modbusTcpErrorHandling:' + JSON.stringify(err))\n        }\n      }\n\n      if ((err.errno && coreModbusClient.networkErrors.includes(err.errno)) ||\n        (err.code && coreModbusClient.networkErrors.includes(err.code))) {\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.modbusSerialErrorHandling = function (err) {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      if (node.showErrors) {\n        node.error(err)\n      }\n\n      if (node.failureLogEnabled) {\n        if (err.message) {\n          coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + err.message)\n        } else {\n          coreModbusClient.modbusSerialDebug('modbusSerialErrorHandling:' + JSON.stringify(err))\n        }\n      }\n\n      node.stateService.send('BREAK')\n    }\n\n    node.openSerialClient = function () {\n      // some delay for windows\n      if (node.actualServiceState.value === 'opened') {\n        verboseLog('time to open Unit ' + node.unit_id)\n        coreModbusClient.modbusSerialDebug('modbus connection opened')\n        node.client.setID(node.unit_id)\n        node.client.setTimeout(parseInt(node.clientTimeout))\n        node.client._port.on('close', node.onModbusClose)\n        node.stateService.send('CONNECT')\n      } else {\n        verboseLog('wrong state on connect serial ' + node.actualServiceState.value)\n        coreModbusClient.modbusSerialDebug('modbus connection not opened state is %s', node.actualServiceState.value)\n        node.stateService.send('BREAK')\n      }\n    }\n\n    node.onModbusClose = function () {\n      coreModbusQueue.queueSerialUnlockCommand(node)\n      /* istanbul ignore next */\n      verboseWarn('Modbus closed port')\n      coreModbusClient.modbusSerialDebug('modbus closed port')\n      node.stateService.send('CLOSE')\n    }\n\n    node.on('customModbusMessage', function (msg, cb, cberr) {\n      // const state = node.actualServiceState\n      coreModbusClient.customModbusMessage(node, msg, cb, cberr)\n    })\n\n    node.on('readModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n      if (node.isInactive()) {\n        cberr(new Error('Client Not Ready To Read At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.readModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued read msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.readModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.on('writeModbus', function (msg, cb, cberr) {\n      const state = node.actualServiceState\n\n      if (node.isInactive()) {\n        cberr(new Error('Client Not Ready To Write At State ' + state.value), msg)\n      } else {\n        if (node.bufferCommands) {\n          coreModbusQueue.pushToQueueByUnitId(node, coreModbusClient.writeModbus, msg, cb, cberr).then(function () {\n            node.queueLog(JSON.stringify({\n              info: 'queued write msg',\n              message: msg.payload,\n              state: state.value,\n              queueLength: node.bufferCommandList.get(msg.queueUnitId).length\n            }))\n          }).catch(function (err) {\n            cberr(err, msg)\n          }).finally(function () {\n            node.stateService.send('QUEUE')\n          })\n        } else {\n          coreModbusClient.writeModbus(node, msg, cb, cberr)\n        }\n      }\n    })\n\n    node.activateSending = function (msg) {\n      node.sendingAllowed.set(msg.queueUnitId, true)\n      coreModbusQueue.queueSerialUnlockCommand(node)\n\n      return new Promise(\n        function (resolve, reject) {\n          try {\n            if (node.bufferCommands) {\n              node.queueLog(JSON.stringify({\n                info: 'queue response activate sending',\n                queueLength: node.bufferCommandList.length,\n                sendingAllowed: node.sendingAllowed.get(msg.queueUnitId),\n                serialSendingAllowed: node.serialSendingAllowed,\n                queueUnitId: msg.queueUnitId\n              }))\n\n              if (coreModbusQueue.checkQueuesAreEmpty(node)) {\n                node.stateService.send('EMPTY')\n              }\n            }\n            resolve()\n          } catch (err) {\n            reject(err)\n          }\n        })\n    }\n\n    verboseLog('initialized')\n    node.setMaxListeners(unlimitedListeners)\n\n    node.on('reconnect', function () {\n      node.stateService.send('CLOSE')\n    })\n\n    node.on('dynamicReconnect', function (msg, cb, cberr) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        throw new Error('Message Or Payload Not Valid')\n      }\n\n      coreModbusClient.internalDebug('Dynamic Reconnect Parameters ' + JSON.stringify(msg.payload))\n      if (coreModbusClient.setNewNodeSettings(node, msg)) {\n        cb(msg)\n      } else {\n        cberr(new Error('Message Or Payload Not Valid'), msg)\n      }\n      coreModbusClient.internalDebug('Dynamic Reconnect Starts on actual state ' + node.actualServiceState.value)\n      node.stateService.send('SWITCH')\n    })\n\n    node.on('close', function (done) {\n      const nodeIdentifierName = node.name || node.id\n      node.closingModbus = true\n      verboseLog('stop fsm on close ' + nodeIdentifierName)\n      node.stateService.send('STOP')\n      verboseLog('close node ' + nodeIdentifierName)\n      node.internalDebugLog('close node ' + nodeIdentifierName)\n\n      if (node.client) {\n        if (node.client.isOpen) {\n          node.client.close(function (err) {\n            if (err) {\n              /* istanbul ignore next */\n              verboseLog('Connection closed with error ' + nodeIdentifierName)\n            } else {\n              /* istanbul ignore next */\n              verboseLog('Connection closed well ' + nodeIdentifierName)\n            }\n            done()\n          })\n        } else {\n          /* istanbul ignore next */\n          verboseLog('connection was closed ' + nodeIdentifierName)\n          done()\n        }\n\n        node.client.removeAllListeners()\n      } else {\n        /* istanbul ignore next */\n        verboseLog('Connection closed simple ' + nodeIdentifierName)\n        done()\n      }\n\n      node.removeAllListeners()\n    })\n\n    // handle using as config node\n    node.registeredNodeList = {}\n\n    node.registerForModbus = function (clientUserNodeId) {\n      node.registeredNodeList[clientUserNodeId] = clientUserNodeId\n      if (Object.keys(node.registeredNodeList).length === 1) {\n        node.closingModbus = false\n        node.stateService.send('NEW')\n        node.stateService.send('INIT')\n      }\n      node.emit('mbregister', clientUserNodeId)\n    }\n\n    node.setStoppedState = function (clientUserNodeId, done) {\n      node.stateService.send('STOP')\n      node.emit('mbderegister', clientUserNodeId)\n      done()\n    }\n\n    node.closeConnectionWithoutRegisteredNodes = function (clientUserNodeId, done) {\n      if (Object.keys(node.registeredNodeList).length === 0) {\n        node.closingModbus = true\n        if (node.client && node.actualServiceState.value !== 'stopped') {\n          if (node.client.isOpen) {\n            node.client.close(function () {\n              node.setStoppedState(clientUserNodeId, done)\n            })\n          } else {\n            node.setStoppedState(clientUserNodeId, done)\n          }\n        } else {\n          node.setStoppedState(clientUserNodeId, done)\n        }\n      } else {\n        node.setStoppedState(clientUserNodeId, done)\n      }\n    }\n\n    node.deregisterForModbus = function (clientUserNodeId, done) {\n      try {\n        delete node.registeredNodeList[clientUserNodeId]\n        if (node.closingModbus) {\n          done()\n          node.emit('mbderegister', clientUserNodeId)\n        } else {\n          node.closeConnectionWithoutRegisteredNodes(clientUserNodeId, done)\n        }\n      } catch (err) {\n        /* istanbul ignore next */\n        verboseWarn(err.message + ' on de-register node ' + clientUserNodeId)\n        node.error(err)\n        done()\n      }\n    }\n\n    node.isInactive = function () {\n      return _.isUndefined(node.actualServiceState) || node.messageAllowedStates.indexOf(node.actualServiceState.value) === -1\n    }\n\n    node.isActive = function () {\n      return !node.isInactive()\n    }\n\n    node.isReadyToSend = function (node) {\n      if (node.actualServiceState.matches('queueing') || node.actualServiceState.matches('activated')) {\n        return true\n      }\n\n      verboseWarn('Client not ready to send')\n      return false\n    }\n  }\n\n  RED.nodes.registerType('modbus-client', ModbusClientNode)\n\n  /* istanbul ignore next */\n  RED.httpAdmin.get('/modbus/serial/ports', RED.auth.needsPermission('serial.read'), function (req, res) {\n    const SerialPort = require('serialport')\n    SerialPort.SerialPort.list().then(ports => {\n      res.json(ports)\n    }).catch(err => {\n      /* istanbul ignore next */\n      res.json([err.message])\n      /* istanbul ignore next */\n      coreModbusClient.internalDebug(err.message)\n    })\n  })\n}\n"]}